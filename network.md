### OSI 与 TCP/IP 各层的结构与功能，都有哪些协议？

![层级结构](https://images.xiaozhuanlan.com/photo/2019/5ae3e9cebae172f793aac837fbab5c9b.png)

#### 应用层

应用进程（进程：主机中正在运行的程序）间的通信和交互的规则

DNS（53）、HTTP（80）、FTP（20 传输数据,21 传输控制信息）、SMTP、POP3、RIP

#### 传输层

TCP、UDP

### 网络层

IP、ICMP、ARP

![七层体系总结](https://images.xiaozhuanlan.com/photo/2019/2057ef65725794622d3d6479a9d300a3.png)



### TCP 和 UDP 的区别

|                    | TCP                            | UDP                                    |
| :----------------- | :----------------------------- | -------------------------------------- |
| 连接               | 面向连接                       | 无连接                                 |
| 可靠               | 可靠传输（流量控制、拥塞控制） | 不可靠传输                             |
| 传输方式           | 面向字节流                     | 面向报文                               |
| 首部开销           | 首部最小 20 字节，最大 60 字节 | 首部开销小，仅 8 字节                  |
| 连接对象个数       | 只能是一对一通信               | 支持一对一，一对多，多对一和多对多通信 |
| 适用场景           | 要求可靠传输的应用             | 适用于实时应用                         |
| 应用层协议（应用） | SMTP、HTTP、FTP、TELNET        | DNS、TFTP、IP 电话、视频会议、直播     |

> 面向字节流：TCP 将应用程序传输的数据块看作无结构的字节流，通过缓冲区进行发送和接收。因此可能发生拆分（数据块太大）和拼接（数据块很小）
>
> 面向报文：应用层交给 UDP 多长的报文，UDP 就添加首部之后发送。

![程序实现](https://img-my.csdn.net/uploads/201303/15/1363304870_3150.jpg)

#### TCP、UDP 首部格式

**TCP**

最小 20 字节，最大 60 字节

![TCP首部](https://pic3.zhimg.com/80/v2-3bd45a13afe868cae6225d75b85e9c36_720w.jpg)

序号：每次传输字节流的编号（301, 401, 501... 数据长度为 100 时）

确认号：期望收到的下一个报文段序号（收到 501 开头的 100 字节，期望收到 601）

数据偏移：首部长度，也就是指明数据部分的开头在哪

**UDP**

 8 个字节

![UDP首部](https://pic1.zhimg.com/80/v2-c01a6511abf81f867fd0e531bd51af2c_720w.jpg)

### TCP 三次握手、四次挥手

#### 三次握手

作用：双方都能明确自己和对方的收、发能力是正常的

**三次握手过程**

第一次：客户端——>服务器 `SYN=1 seq=x`

第二次：服务器——>客户端 `SYN=1 ACK=1 ack=x+1 seq=y`

第三次：客户端——>服务器 `ACK=1 ack=y+1 seq=x+1`

- 客户端视角

第二次：客户端收发正常，服务器收发正常

- 服务器视角

第三次：客户端收发正常，服务器收发正常

**为什么三次握手？**

1. 只有三次握手才能够让双方都明确自己和对方的收、发能力是正常的

如果只有两次客户端能够明确自己和对方收发正常，但是服务器不知道自己的发送能力是否正常

2. 防止已过期的连接请求到达服务器，因而产生错误

#### 四次挥手

**四次挥手过程**

第一次：客户端——>服务器 `FIN=1 seq=u`

第二次：服务器——>客户端 `ACK=1 ack=u+1 seq=v`

第三次：服务器——>客户端 `FIN=1 ACK=1 ack=u+1 seq=w`

第四次：客户端——>服务器 `ACK=1 ack=w+1 seq=u+1`

客户端进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接

**为什么四次挥手？**

因为 TCP 是全双工通信的

主动方发送断开连接的请求只表明主动方不会再发送数据报文，但是主动方仍可以接收数据报文。在被动方收到主动方断开连接的请求时，可能还有相信数据报文需要发送。因此先发送 ACK 报文告知已收到，在数据报文全部发送完毕后发送 FIN 和 ACK 告知主动方。

**为什么第四次握手之后有 TIME_WAIT？**

TIME_WAIT 状态等待 **2 倍 MSL**(Max Segment Lifetime)

1. 保证 TCP 协议的全双工连接能够**可靠**关闭 

如果主动端直接 CLOSED，被动端没有收到 ACK 会在超时后继续发送 FIN，但是不会收到 ACK 而是收到 RST（Reset the connection）

2. 保证这次连接的重复数据段从网络中消失

如果主动端 CLOSED 后又建立了相同端口的 TCP 连接，可能会出现数据包的混淆。

### TCP 如何保证可靠传输？

对发送包进行编号、校验和（数据是否修改）、流量控制（接收者）、拥塞控制（网络）、自动重传请求（ARQ）

- 流量控制（作用于接收者）

`滑动窗口` 接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端

- 拥塞控制（作用于网络）

慢开始和拥塞避免

1. 慢开始：拥塞窗口 < 阈值——指数增长
2. 拥塞避免：拥塞窗口 > 阈值——加法增大
3. 超时之后乘法减小

快重传快恢复

1. 快重传：接收方收到 3 个同样的确认就立刻重传，不等到超时
2. 快恢复：从拥塞窗口的一半开始加法增大

- 自动重传请求（ARQ）

停止等待 ARQ 协议：发送窗口 == 1 & 接收窗口 == 1

连续 ARQ 协议

1. GoBackN：发送窗口 > 1，接收窗口 = 1。报文出错后，发送方将重传过去的n个报文

![](https://upload-images.jianshu.io/upload_images/1341067-e6e506705bd6e74c.png?imageMogr2/auto-orient/strip|imageView2/2/w/451/format/webp)

2. 选择重传：发送窗口 > 1，接收窗口 > 1。每个数据包设有一个计时器，只重传没有 ACK 的数据包

![](https://upload-images.jianshu.io/upload_images/1341067-05a695c438a64f89.png?imageMogr2/auto-orient/strip|imageView2/2/w/644/format/webp)


## 回溯算法

[关于回溯算法，你该了解这些！](https://mp.weixin.qq.com/s/gjSgJbNbd1eAA5WkA-HeWw)

- 组合问题：N 个数里面按一定规则找出 k 个数的集合
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 棋盘问题：N 皇后，解数独等等

排列问题 for 循环从 0 开始，组合问题 for 循环从 startIndex 开始

### 排列问题

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```java
class Solution {
    // 使用 ArrayList contains() 方法判断元素是否重复
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> path = new ArrayList<>();
        backtracking(path, nums);
        return res;
    }

    public void backtracking(List<Integer> path, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(path.contains(nums[i]))     continue;
            path.add(nums[i]);
            backtracking(path, nums);
            path.remove(path.size() - 1);
        }
    }
}

class Solution {
    // 使用布尔数组判断元素是否重复
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        backtracking(path, used, nums);
        return res;
    }

    public void backtracking(List<Integer> path, boolean[] used, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(used[i])     continue;
            path.add(nums[i]);
            used[i] = true;
            backtracking(path, used, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

> 排列问题的特点：
>
> 每层都是从 0 开始搜索而不是 startIndex
>
> 需要 used 数组记录 path 里都放了哪些元素

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        Arrays.sort(nums);
        backtracking(path, 0, used, nums);
        return res;
    }

    public void backtracking(List<Integer> path, int start, boolean[] used, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(i > 0 && nums[i] == nums[i - 1] && !used[i-1])   continue;
            // 通过 used[i] 来进行数组的后移
            if(used[i])    continue;
            path.add(nums[i]);
            used[i] = true;
            backtracking(path, i + 1, used, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

#### [60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

```
第 k 个全排列
输入：n = 3, k = 3
输出："213"
```

```java
class Solution {
    String res = "";
    int num = 0;
    public String getPermutation(int n, int k) {
        StringBuilder path = new StringBuilder();
        boolean[] used = new boolean[n];
        backtracking(path, used, n, k);
        return res;
    }

    public void backtracking(StringBuilder path, boolean[] used, int n, int k) {
        if(path.length() == n) {
            num++;
            if(num == k) {
                res = path.toString();
                return;
            }
        }

        for(int i = 1; i <= n; i++) {
            if(used[i-1])    continue;
            path.append(i);
            used[i-1] = true;
            backtracking(path, used, n, k);
            path.deleteCharAt(path.length() - 1);
            used[i-1] = false;
        }
    }
}
```

[可剪枝](https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/)

### 组合问题

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠 startIndex**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        if(k > n)    return res;
        backtracking(0, n, k);
        return res;
    }

    public void backtracking(int start, int n, int k) {
        if(path.size() == k) {
            res.add(new ArrayList(path));
            return;
        }
        // if(start == n)    return; 因为 k < n 所以树的深度最大就为 k，不会到达 n

        //for(int i = start; i < n; i++) {
        // 剪枝操作，当后面元素的个数不满足 k-path.size() 时就不用再搜索了
        for(int i = start; i <= n-(k-path.size()); i++) {
            path.add(i + 1);
            backtracking(i + 1, n, k);
            path.remove(path.size() - 1);
        }
    }
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> path = new ArrayList<>();
        Arrays.sort(candidates);
        backtracking(path, 0, candidates, target);
        return res;
    }

    public void backtracking(List<Integer> path, int start, int[] candidates, int target) {
        if(target == 0) {
            res.add(new ArrayList(path));
            return;
        } 
        if(target < 0)  return;

        for(int i = start; i < candidates.length; i++) {
            path.add(candidates[i]);
            target -= candidates[i];
            backtracking(path, i, candidates, target);
            path.remove(path.size() - 1);
            target += candidates[i];
        }
    }
}
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(1, 0, k, n);
        return res;
    }

    public void backtracking(int start, int sum, int k, int target) {
        if(target < sum)    return; // 剪枝
        if(path.size() == k) {
            if(sum == target)    res.add(new ArrayList(path));
            return;
        }


        for(int i = start; i <= 9; i++) {
            path.add(i);
            sum += i;
            backtracking(i + 1, sum, k, target);
            path.remove(path.size() - 1);
            sum -= i;
        }
    }
}
```


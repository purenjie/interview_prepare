## 整体层次

### OSI 与 TCP/IP 各层的结构与功能，都有哪些协议？

![层级结构](https://images.xiaozhuanlan.com/photo/2019/5ae3e9cebae172f793aac837fbab5c9b.png)

#### 应用层

应用进程（进程：主机中正在运行的程序）间的通信和交互的规则

DNS（53）、HTTP（80）、FTP（20 传输数据,21 传输控制信息）、SMTP、POP3、RIP

#### 传输层

TCP、UDP

#### 网络层

IP、ICMP、ARP

![七层体系总结](https://images.xiaozhuanlan.com/photo/2019/2057ef65725794622d3d6479a9d300a3.png)

## 应用层 & 表示层 & 会话层

### HTTP 和 HTTPS 分别属于哪一层？

HTTP：应用层

HTTPS：会话层、表示层

HTTPS 相比 HTTP 多了一层 SSL/TLS

![HTTP 和 HTTPS](https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_720w.png)

### HTTP 和 HTTPS 的区别？

- **端口**

HTTP 是 80 端口；HTTPS 是 443 端口

- **安全性和资源消耗**

HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

HTTP 协议运行在 TCP 之上，所有传输的内容都是明文传输；HTTPS 相比 HTTP 多了一层 SSL/TLS，所有传输的内容都经过加密。

### HTTPS 的加密过程是什么？（腾讯）

SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

**握手阶段——表示层——非对称加密**
SSL 握手协议（SSL Handshake Protocol）：它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

1. 客户端请求服务器
2. 服务器返回证书公钥
3. 客户端验证 CA 证书 & 用公钥加密
4. 服务器使用私钥解密

**通信阶段——会话层——对称加密**

SSL 记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。

5. 使用双方商定的密钥进行对称加密

![](https://upload-images.jianshu.io/upload_images/16796915-df1c6921f2c14805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[TCP、TLS、SSL 和 HTTPS 之间错综复杂的情感纠葛](https://www.sohu.com/a/251746171_216613) 

[图解 SSL/TLS 协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

### HTTP 状态码

![](https://images.xiaozhuanlan.com/photo/2019/be714471b75a4e901581ffb719981796.jpg)

| 状态码 | 状态码英文名称    | 中文描述                                                     |
| ------ | ----------------- | ------------------------------------------------------------ |
| 200    | OK                | 请求成功。一般用于 GET 与 POST 请求                          |
| 301    | Moved Permanently | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 403    | Forbidden         | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found         | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 "您所请求的资源无法找到" 的个性页面 |
| 502    | Bad Gateway       | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |

### HTTP 长连接，短连接

HTTP/1.0 中默认使用短连接，从 HTTP/1.1 起，默认使用长连接，在响应头加入 `Connection:keep-alive` 字段。

短连接就是客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。长连接时在网页打开后不会关闭用于传输 HTTP 数据的 TCP 连接，所以后面客户端再次访问这个服务器时，会继续使用已经建立的连接。

短连接对于服务器来说管理较为简单，但如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费较多时间和带宽。长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。

#### 长连接可能产生的问题和解决方法

- 长连接下客户端一般不会主动关闭连接，随着客户端连接增多会造成服务器端压力过大

采取策略控制连接数量，如关闭一些长时间没有请求发生的连接，限制每个客户端的最大连接数等

### get 请求和 post 请求的区别



### 在浏览器中输入 url 地址 ->> 显示主页的过程 (面试常客)

1. 根据域名，进行DNS域名解析；（DNS 解析）

> DNS 是 UDP 传输，速度快，只需要一个请求一个应答。UDP 传输内容一般不超过 512 字节

2. 拿到解析的IP地址，建立TCP连接；（TCP 连接）
3. 向IP地址，发送HTTP请求；（HTTP 请求）
4. 服务器处理请求；（服务器：处理请求 & 返回结果）
5. 返回响应结果；
6. 关闭TCP连接；（关闭 TCP）
7. 浏览器解析HTML；（浏览器解析 HTML 与渲染）
8. 浏览器布局渲染；

### DNS 解析的流程？

1. 本机 DNS 缓存（hosts 文件、浏览器缓存）
2. 根域名服务器查询返回顶级域名服务器
3. 逐层得到域名对应的 IP 地址
4. 在浏览器缓存域名对应的 IP

![DNS 解析方式](https://i.loli.net/2021/03/10/exNY97RAIuDcnHP.png)



## 传输层

### TCP 和 UDP 的区别

|                    | TCP                            | UDP                                    |
| :----------------- | :----------------------------- | -------------------------------------- |
| 连接               | 面向连接                       | 无连接                                 |
| 可靠               | 可靠传输（流量控制、拥塞控制） | 不可靠传输                             |
| 传输方式           | 面向字节流                     | 面向报文                               |
| 首部开销           | 首部最小 20 字节，最大 60 字节 | 首部开销小，仅 8 字节                  |
| 连接对象个数       | 只能是一对一通信               | 支持一对一，一对多，多对一和多对多通信 |
| 适用场景           | 要求可靠传输的应用             | 适用于实时应用                         |
| 应用层协议（应用） | SMTP、HTTP、FTP、TELNET        | DNS、TFTP、IP 电话、视频会议、直播     |

> 面向字节流：TCP 将应用程序传输的数据块看作无结构的字节流，通过缓冲区进行发送和接收。因此可能发生拆分（数据块太大）和拼接（数据块很小）
>
> 面向报文：应用层交给 UDP 多长的报文，UDP 就添加首部之后发送。

![程序实现](https://img-my.csdn.net/uploads/201303/15/1363304870_3150.jpg)

#### TCP、UDP 首部格式

**TCP**

最小 20 字节，最大 60 字节

![TCP首部](https://pic3.zhimg.com/80/v2-3bd45a13afe868cae6225d75b85e9c36_720w.jpg)

序号：每次传输字节流的编号（301, 401, 501... 数据长度为 100 时）

确认号：期望收到的下一个报文段序号（收到 501 开头的 100 字节，期望收到 601）

数据偏移：首部长度，也就是指明数据部分的开头在哪

**UDP**

 8 个字节

![UDP首部](https://pic1.zhimg.com/80/v2-c01a6511abf81f867fd0e531bd51af2c_720w.jpg)

### TCP 三次握手、四次挥手

#### 三次握手

作用：双方都能明确自己和对方的收、发能力是正常的

**三次握手过程**

第一次：客户端——>服务器 `SYN=1 seq=x`

第二次：服务器——>客户端 `SYN=1 ACK=1 ack=x+1 seq=y`

第三次：客户端——>服务器 `ACK=1 ack=y+1 seq=x+1`

- 客户端视角

第二次：客户端收发正常，服务器收发正常

- 服务器视角

第三次：客户端收发正常，服务器收发正常

**为什么三次握手？**

1. 只有三次握手才能够让双方都明确自己和对方的收、发能力是正常的

如果只有两次客户端能够明确自己和对方收发正常，但是服务器不知道自己的发送能力是否正常

2. 防止已过期的连接请求到达服务器，因而产生错误

#### 四次挥手

**四次挥手过程**

第一次：客户端——>服务器 `FIN=1 seq=u`

第二次：服务器——>客户端 `ACK=1 ack=u+1 seq=v`

第三次：服务器——>客户端 `FIN=1 ACK=1 ack=u+1 seq=w`

第四次：客户端——>服务器 `ACK=1 ack=w+1 seq=u+1`

客户端进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接

**为什么四次挥手？**

因为 TCP 是全双工通信的

主动方发送断开连接的请求只表明主动方不会再发送数据报文，但是主动方仍可以接收数据报文。在被动方收到主动方断开连接的请求时，可能还有相信数据报文需要发送。因此先发送 ACK 报文告知已收到，在数据报文全部发送完毕后发送 FIN 和 ACK 告知主动方。

**为什么第四次握手之后有 TIME_WAIT？**

TIME_WAIT 状态等待 **2 倍 MSL**(Max Segment Lifetime)

1. 保证 TCP 协议的全双工连接能够**可靠**关闭 

如果主动端直接 CLOSED，被动端没有收到 ACK 会在超时后继续发送 FIN，但是不会收到 ACK 而是收到 RST（Reset the connection）

2. 保证这次连接的重复数据段从网络中消失

如果主动端 CLOSED 后又建立了相同端口的 TCP 连接，可能会出现数据包的混淆。

### TCP 如何保证可靠传输？

对发送包进行编号、校验和（数据是否修改）、流量控制（接收者）、拥塞控制（网络）、自动重传请求（ARQ）

- 流量控制（作用于接收者）

`滑动窗口` 接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端

- 拥塞控制（作用于网络）

慢开始和拥塞避免

1. 慢开始：拥塞窗口 < 阈值——指数增长
2. 拥塞避免：拥塞窗口 > 阈值——加法增大
3. 超时之后乘法减小

快重传快恢复

1. 快重传：接收方收到 3 个同样的确认就立刻重传，不等到超时
2. 快恢复：从拥塞窗口的一半开始加法增大

- 自动重传请求（ARQ）

停止等待 ARQ 协议：发送窗口 == 1 & 接收窗口 == 1

连续 ARQ 协议

1. GoBackN：发送窗口 > 1，接收窗口 = 1。报文出错后，发送方将重传过去的n个报文

![](https://upload-images.jianshu.io/upload_images/1341067-e6e506705bd6e74c.png?imageMogr2/auto-orient/strip|imageView2/2/w/451/format/webp)

2. 选择重传：发送窗口 > 1，接收窗口 > 1。每个数据包设有一个计时器，只重传没有 ACK 的数据包

![](https://upload-images.jianshu.io/upload_images/1341067-05a695c438a64f89.png?imageMogr2/auto-orient/strip|imageView2/2/w/644/format/webp)


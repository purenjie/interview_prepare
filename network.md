## 整体层次

### OSI 与 TCP/IP 各层的结构与功能，都有哪些协议？

![层级结构](https://images.xiaozhuanlan.com/photo/2019/5ae3e9cebae172f793aac837fbab5c9b.png)

#### 应用层

应用进程（进程：主机中正在运行的程序）间的通信和交互的规则

DNS（53）、HTTP（80）、FTP（20 传输数据,21 传输控制信息）、SMTP、POP3、RIP

#### 传输层

TCP、UDP

#### 网络层

IP、ICMP、ARP

![七层体系总结](https://images.xiaozhuanlan.com/photo/2019/2057ef65725794622d3d6479a9d300a3.png)

## 应用层 & 表示层 & 会话层

### HTTP 和 HTTPS 分别属于哪一层？

HTTP：应用层

HTTPS：会话层（通过 SSL/TLS 进行非对称加密建立通话）

HTTPS 相比 HTTP 多了一层 SSL/TLS

![HTTP 和 HTTPS](https://pic1.zhimg.com/80/v2-54ff04e1b0cc698f08f76d6356f59fac_720w.png)

### HTTP 和 HTTPS 的区别？

- **端口**

HTTP 是 80 端口；HTTPS 是 443 端口

- **安全性**

HTTP 协议运行在 TCP 之上，所有传输的内容都是明文传输；HTTPS 相比 HTTP 多了一层 SSL/TLS，所有传输的内容都经过加密。

### HTTPS 的加密过程是什么？（腾讯）

SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

**握手阶段——表示层——非对称加密**
SSL 握手协议（SSL Handshake Protocol）：它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

1. 客户端请求服务器
2. 服务器返回证书公钥
3. 客户端验证 CA 证书 & 用公钥加密
4. 服务器使用私钥解密

**通信阶段——会话层——对称加密**

SSL 记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。

5. 使用双方商定的密钥进行对称加密

![](https://upload-images.jianshu.io/upload_images/16796915-df1c6921f2c14805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[TCP、TLS、SSL 和 HTTPS 之间错综复杂的情感纠葛](https://www.sohu.com/a/251746171_216613) 

[图解 SSL/TLS 协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

### HTTP 状态码

![](https://images.xiaozhuanlan.com/photo/2019/be714471b75a4e901581ffb719981796.jpg)

| 状态码 | 状态码英文名称    | 中文描述                                                     |
| ------ | ----------------- | ------------------------------------------------------------ |
| 200    | OK                | 请求成功。一般用于 GET 与 POST 请求                          |
| 301    | Moved Permanently | 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 403    | Forbidden         | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found         | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 "您所请求的资源无法找到" 的个性页面 |
| 502    | Bad Gateway       | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |

### HTTP 长连接，短连接

HTTP/1.0 中默认使用短连接，从 HTTP/1.1 起，默认使用长连接，在响应头加入 `Connection:keep-alive` 字段。

短连接就是客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。长连接是在网页打开后不会关闭用于传输 HTTP 数据的 TCP 连接，所以后面客户端再次访问这个服务器时，会继续使用已经建立的连接。

短连接对于服务器来说管理较为简单，但如果客户请求频繁，将在 TCP 的建立和断开上浪费时间和带宽。长连接可以省去多次 TCP 建立和断开的操作，节约时间和带宽。对于频繁请求资源的客户端适合使用长连接。

#### 长连接可能产生的问题和解决方法

- 长连接下客户端一般不会主动关闭连接，随着客户端连接增多会造成服务器端压力过大

采取策略控制连接数量，如关闭一些长时间没有请求发生的连接，限制每个客户端的最大连接数等

### HTTP/1.0 和 HTTP/1.1 的区别?

- **长连接** : 在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。默认开启 Connection： keep-alive（HTTP/1.1 的持续连接有非流水线方式（收到响应报文之前就能发送新的请求报文）和流水线方式）
- **错误状态响应码**：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- **缓存处理** :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Match，If-None-Match，If-Unmodified-Since 等更多可供选择的**缓存头**来控制缓存策略。
- **带宽优化**：在 HTTP1.0 中客户端请求资源时服务器会传送整个对象，有时会浪费带宽。在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。
- **Host 请求头**：HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机并且共享同一 IP 地址。HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。

### HTTP/1.X 和 HTTP/2.0 的区别

- **传输方式**：/1.X 采用文本（字符串）传送，HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成数据流，流具有（流 ID）标识和优先级，通过**优先级**以及**流依赖**能够一定程度上解决**关键请求被阻塞**的问题。
- **多路复用**：HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过**同一个 HTTP 请求**可以实现**多个 HTTP 请求传输**，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。
- **头部压缩**：HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。
- **服务器推送**：HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。

### HTTP/3 了解吗？

- 使用 UDP 作为传输层进行通信
- 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性（建立连接过程中完成了 TLS 加密握手）
- 建立连接快，正常只需要 1 RTT 即可建立连接
- 使用 QPACK 进行头部压缩（HTTP/2 中使用 HPACK 要求传输过程有序）

![HTTP协议](https://pic.leetcode-cn.com/1612458489-HxhiPr-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%98%E5%8C%96.png)

### HTTP是不保存状态的协议,如何保存用户状态?

HTTP 协议自身不对请求和响应之间的通信状态进行保存。

- 基于 Session 实现的会话保持

服务端通过给特定用户创建特定 Session，就可以标识特定用户并且跟踪。会话标识一般保存在客户端 Cookie 中，通过带 Cookie 的 HTTP 请求实线客户端和服务器的会话保持。

优点：状态信息保存在服务器端，安全性高

缺点：分布式服务器浏览器发送的 HTTP 请求不一定能到达同一服务器，基于 Session 的方法就不能实现会话保持。（解决方法：采用中间件如 Redis，将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息）

- 基于 Cookie 实现的会话保持

服务器返回响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析响应头并保存 Cookie，之后发送 HTTP 请求都带上 Cookie 字段，从而实现状态保持。

优点：服务器不用保存状态信息， 减轻服务器存储压力

缺点：不够安全，因为状态信息存储在客户端，所以不能在会话中保存机密数据；浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。

**拓展：Cookie 被禁用了怎么办？**

通过重写 URL 的方式将 Session ID 放在 URL 的参数里

### Cookie的作用是什么?和Session有什么区别？

（Cookie 和 Session都是用来**跟踪浏览器用户身份的会话方式**，但是两者的应用场景不太一样。）

Cookie 保存在客户端，Session 保存在服务器上。

Cookie 存放在本地浏览器，可能会产生安全问题 

Session 的实现依赖于 Cookie，经常会把 Session ID 存放在 Cookie 中。

Cookies 可以用来跟踪会话，也可以保存用户的特点或者用户名密码之类的信息。Session 用来跟踪会话。

### GET 和 POST 的区别？

- get 提交的数据会放在 URL 之后，请求参数会被保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
- get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制
- get 请求只支持 URL 编码，post 请求支持多种编码格式
- get 只支持 ASCII 字符格式的参数，而 post 方法没有限制
- **get 产生一个 TCP 数据包，post 产生两个 TCP 数据包**。对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。

### 在浏览器中输入 url 地址 ->> 显示主页的过程 (面试常客)

1. 根据域名，进行DNS域名解析；（DNS 解析）

> DNS 是 UDP 传输，速度快，只需要一个请求一个应答。UDP 传输内容一般不超过 512 字节

2. 拿到解析的IP地址，建立TCP连接；（TCP 连接）
3. 向IP地址，发送HTTP请求；（HTTP 请求）
4. 服务器处理请求；（服务器：处理请求 & 返回结果）
5. 返回响应结果；
6. 关闭TCP连接；（关闭 TCP）
7. 浏览器解析HTML；（浏览器解析 HTML 与渲染）
8. 浏览器布局渲染；

### DNS 解析的流程？

1. 本机 DNS 缓存（hosts 文件、浏览器缓存）
2. 根域名服务器查询返回顶级域名服务器
3. 逐层得到域名对应的 IP 地址
4. 在浏览器缓存域名对应的 IP

![DNS 解析方式](https://i.loli.net/2021/03/10/exNY97RAIuDcnHP.png)



## 传输层

传输层提供应用进程之间的逻辑通信（端到段的通信）

网络层提供的是主机之间的逻辑通信

### TCP 和 UDP 的区别

|                    | TCP                            | UDP                                    |
| :----------------- | :----------------------------- | -------------------------------------- |
| 连接               | 面向连接                       | 无连接                                 |
| 可靠               | 可靠传输（流量控制、拥塞控制） | 不可靠传输                             |
| 传输方式           | 面向字节流                     | 面向报文                               |
| 首部开销           | 首部最小 20 字节，最大 60 字节 | 首部开销小，仅 8 字节                  |
| 连接对象个数       | 只能是一对一通信               | 支持一对一，一对多，多对一和多对多通信 |
| 适用场景           | 要求可靠传输的应用             | 适用于实时应用                         |
| 应用层协议（应用） | SMTP、HTTP、FTP、TELNET        | DNS、TFTP、IP 电话、视频会议、直播     |

> 面向字节流：TCP 将应用程序传输的数据块看作无结构的字节流，通过缓冲区进行发送和接收。因此可能发生拆分（数据块太大）和拼接（数据块很小）
>
> 面向报文：应用层交给 UDP 多长的报文，UDP 就添加首部之后发送。

![程序实现](https://img-my.csdn.net/uploads/201303/15/1363304870_3150.jpg)

#### TCP、UDP 首部格式

**TCP**

最小 20 字节，最大 60 字节

![TCP首部](https://pic3.zhimg.com/80/v2-3bd45a13afe868cae6225d75b85e9c36_720w.jpg)

序号：每次传输字节流的编号（301, 401, 501... 数据长度为 100 时）

确认号：期望收到的下一个报文段序号（收到 501 开头的 100 字节，期望收到 601）

数据偏移：首部长度，也就是指明数据部分的开头在哪

**UDP**

 8 个字节

![UDP首部](https://pic1.zhimg.com/80/v2-c01a6511abf81f867fd0e531bd51af2c_720w.jpg)

### TCP 三次握手、四次挥手

#### 三次握手

作用：双方都能明确自己和对方的收、发能力是正常的

**三次握手过程**

第一次：客户端——>服务器 `SYN=1 seq=x`

第二次：服务器——>客户端 `SYN=1 ACK=1 ack=x+1 seq=y`

第三次：客户端——>服务器 `ACK=1 ack=y+1 seq=x+1`

- 客户端视角

第二次：客户端收发正常，服务器收发正常

- 服务器视角

第三次：客户端收发正常，服务器收发正常

**为什么三次握手？**

1. 只有三次握手才能够让双方都明确自己和对方的收、发能力是正常的

如果只有两次客户端能够明确自己和对方收发正常，但是服务器不知道自己的发送能力是否正常

2. 防止已过期的连接请求到达服务器，因而产生错误

#### 四次挥手

**四次挥手过程**

第一次：客户端——>服务器 `FIN=1 seq=u`

第二次：服务器——>客户端 `ACK=1 ack=u+1 seq=v`

服务器进入 CLOSE_WAIT 状态

第三次：服务器——>客户端 `FIN=1 ACK=1 ack=u+1 seq=w`

第四次：客户端——>服务器 `ACK=1 ack=w+1 seq=u+1`

客户端进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接

![四次挥手](https://img-blog.csdnimg.cn/20200308171409195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbnJlbjIyNA==,size_16,color_FFFFFF,t_70)

**为什么四次挥手？**

因为 TCP 是全双工通信的

主动方发送断开连接的请求只表明主动方不会再发送数据报文，但是主动方仍可以接收数据报文。在被动方收到主动方断开连接的请求时，可能还有相信数据报文需要发送。因此先发送 ACK 报文告知已收到，在数据报文全部发送完毕后发送 FIN 和 ACK 告知主动方。

**为什么第四次握手之后有 TIME_WAIT？**

TIME_WAIT 状态等待 **2 倍 MSL**(Max Segment Lifetime)

1. 保证 TCP 协议的全双工连接能够**可靠**关闭 

如果主动端直接 CLOSED，被动端没有收到 ACK 会在超时后继续发送 FIN，但是不会收到 ACK 而是收到 RST（Reset the connection）

2. 保证这次连接的重复数据段从网络中消失

如果主动端 CLOSED 后又建立了相同端口的 TCP 连接，可能会出现数据包的混淆。

#### 机器有大量 time_wait 连接

**出现原因**

在 `高并发短连接` 的 TCP 服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量 socket 处于 TIMEWAIT 状态。

> 为什么服务器会进入 TIMEWAIT 状态？
>
> 服务器（MySQL 服务器）接收客户端 quit 命令后，等待客户端发送 FIN 断开连接效率低，所以服务器主动断开连接，就会进入 TIMEWAIT 状态
>
> [机器上出现大量 time_wait 怎么办](https://blog.csdn.net/fanren224/article/details/89849276)

**产生问题**

TIME_WAIT 状态下仍然占用端口，服务器一共有 6w 多个端口（一个 IP 地址的端口通过 16 bit（比特）进行编号，最多可以有 65536 个端口），会出现客户端无法向服务端创建新的 socket 连接的情况。

**解决方法**

- 客户端改用长连接（长连接比短连接从根本上减少了关闭连接的次数，减少了 TIME_WAIT 状态的产生数量）
- 客户端在断开连接时，不用 quit 的方式退出，直接发 FIN 或者 RST

- 修改 linux 内核减小 MSL 时间

### TCP 如何保证可靠传输？

校验、序号、确认和重传机制来达到目的。

对发送包进行编号、校验和（数据是否修改）、流量控制（接收者）、拥塞控制（网络）、自动重传请求（ARQ）

- 流量控制（接收者控制窗口容量，用于发送和接收的速度匹配）

基于滑动窗口协议

接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端

![image-20210311103232182](https://i.loli.net/2021/03/11/54ApkbwvtBhP3VL.png)

- 拥塞控制（作用于网络）

慢开始和拥塞避免

1. 慢开始：拥塞窗口 < 阈值——指数增长
2. 拥塞避免：拥塞窗口 > 阈值——加法增大
3. 超时之后乘法减小

![image-20210311103709111](https://i.loli.net/2021/03/11/tcW2jGaFQ8STEr1.png)

快重传快恢复

1. 快重传：发送方收到 3 个重复 ACK 报文直接重传对方未收到的报文段，不等到超时
2. 快恢复：从拥塞窗口的一半开始加法增大

![image-20210311104002915](https://i.loli.net/2021/03/11/hNxZkzJ2lKEX8fr.png)

> 流量控制在于点对点的通信量控制，抑制发送端发送速率，达到发送端和接收端的速度匹配
>
> 拥塞控制在于网络负荷的控制，让网络能更有效地进行数据传输

- 自动重传请求（ARQ）

停止等待 ARQ 协议：发送窗口 == 1 & 接收窗口 == 1

连续 ARQ 协议

1. GoBackN：发送窗口 > 1，接收窗口 = 1。报文出错后，发送方将重传过去的n个报文

![](https://upload-images.jianshu.io/upload_images/1341067-e6e506705bd6e74c.png?imageMogr2/auto-orient/strip|imageView2/2/w/451/format/webp)

2. 选择重传：发送窗口 > 1，接收窗口 > 1。每个数据包设有一个计时器，只重传没有 ACK 的数据包

![](https://upload-images.jianshu.io/upload_images/1341067-05a695c438a64f89.png?imageMogr2/auto-orient/strip|imageView2/2/w/644/format/webp)

### URI和URL的区别是什么?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。
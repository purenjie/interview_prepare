## 回溯算法

[关于回溯算法，你该了解这些！](https://mp.weixin.qq.com/s/gjSgJbNbd1eAA5WkA-HeWw)

- 组合问题：N 个数里面按一定规则找出 k 个数的集合
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 棋盘问题：N 皇后，解数独等等

排列问题 for 循环从 0 开始，组合问题 for 循环从 startIndex 开始

### 排列问题

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```java
class Solution {
    // 使用 ArrayList contains() 方法判断元素是否重复
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> path = new ArrayList<>();
        backtracking(path, nums);
        return res;
    }

    public void backtracking(List<Integer> path, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(path.contains(nums[i]))     continue;
            path.add(nums[i]);
            backtracking(path, nums);
            path.remove(path.size() - 1);
        }
    }
}

class Solution {
    // 使用布尔数组判断元素是否重复
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        backtracking(path, used, nums);
        return res;
    }

    public void backtracking(List<Integer> path, boolean[] used, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(used[i])     continue;
            path.add(nums[i]);
            used[i] = true;
            backtracking(path, used, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

> 排列问题的特点：
>
> 每层都是从 0 开始搜索而不是 startIndex
>
> 需要 used 数组记录 path 里都放了哪些元素

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        Arrays.sort(nums);
        backtracking(path, 0, used, nums);
        return res;
    }

    public void backtracking(List<Integer> path, int start, boolean[] used, int[] nums) {
        if(path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < nums.length; i++) {
            if(i > 0 && nums[i] == nums[i - 1] && !used[i-1])   continue;
            // 通过 used[i] 来进行数组的后移
            if(used[i])    continue;
            path.add(nums[i]);
            used[i] = true;
            backtracking(path, i + 1, used, nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

#### [60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

```
第 k 个全排列
输入：n = 3, k = 3
输出："213"
```

```java
class Solution {
    String res = "";
    int num = 0;
    public String getPermutation(int n, int k) {
        StringBuilder path = new StringBuilder();
        boolean[] used = new boolean[n];
        backtracking(path, used, n, k);
        return res;
    }

    public void backtracking(StringBuilder path, boolean[] used, int n, int k) {
        if(path.length() == n) {
            num++;
            if(num == k) {
                res = path.toString();
                return;
            }
        }

        for(int i = 1; i <= n; i++) {
            if(used[i-1])    continue;
            path.append(i);
            used[i-1] = true;
            backtracking(path, used, n, k);
            path.deleteCharAt(path.length() - 1);
            used[i-1] = false;
        }
    }
}
```

[可剪枝](https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/)

### 组合问题

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠 startIndex**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        if(k > n)    return res;
        backtracking(0, n, k);
        return res;
    }

    public void backtracking(int start, int n, int k) {
        if(path.size() == k) {
            res.add(new ArrayList(path));
            return;
        }
        // if(start == n)    return; 因为 k < n 所以树的深度最大就为 k，不会到达 n

        //for(int i = start; i < n; i++) {
        // 剪枝操作，当后面元素的个数不满足 k-path.size() 时就不用再搜索了
        for(int i = start; i <= n-(k-path.size()); i++) {
            path.add(i + 1);
            backtracking(i + 1, n, k);
            path.remove(path.size() - 1);
        }
    }
}
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(1, 0, k, n);
        return res;
    }

    public void backtracking(int start, int sum, int k, int target) {
        if(target < sum)    return; // 剪枝
        if(path.size() == k) {
            if(sum == target)    res.add(new ArrayList(path));
            return;
        }


        for(int i = start; i <= 9; i++) {
            path.add(i);
            sum += i;
            backtracking(i + 1, sum, k, target);
            path.remove(path.size() - 1);
            sum -= i;
        }
    }
}
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

```java
class Solution {
    // 多个集合的组合
    Map<Character, String> map = new HashMap<>();
    List<String> res = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        map.put('2', "abc");
        map.put('3', "def");
        map.put('4', "ghi");
        map.put('5', "jkl");
        map.put('6', "mno");
        map.put('7', "pqrs");
        map.put('8', "tuv");
        map.put('9', "wxyz");

        if(digits.equals(""))    return res;
        backtracking(0, digits, digits.length());
        return res;
    }

    public void backtracking(int start, String digits, int depth) {
        if(sb.length() == depth) {
            res.add(sb.toString());
            return;
        }

        char[] arr = map.get(digits.charAt(start)).toCharArray();
        for(int j = 0; j < arr.length; j++) {
            sb.append(arr[j]);
            backtracking(start + 1, digits, depth);
            sb.deleteCharAt(sb.length() - 1);
        }
        
    }
}
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

```java
class Solution {
    // 剪枝操作
    // 1. Arrays.sort(candidates);
    // 2. for 循环 i < candidates.length && sum + candidates[i] <= target
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(0, candidates, 0, target);
        return res;
    }

    public void backtracking(int start, int[] candidates, int sum, int target) {
        if(sum == target) {
            res.add(new ArrayList(path));
            return;
        }
        if(sum > target)    return;

        for(int i = start; i < candidates.length; i++) {
            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(i, candidates, sum, target);
            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```

> 如果是一个集合来求组合的话，就需要 startIndex（组合、组合总和）
>
> 如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex（电话号码组合）

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

> 和上一题的区别
>
> 1. 本题 candidates 中的每个数字在每个组合中只能使用一次。
> 2. 本题数组 candidates 的元素是有重复的，而组合总和是无重复元素的数组 candidates

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

```java
class Solution {
    // 去重逻辑为 i > start && candidates[i] == candidates[i - 1]
    // 剪枝同上，sort + for 循环中判断
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(0, candidates, 0, target);
        return res;
    }

    public void backtracking(int start, int[] candidates, int sum, int target) {
        if(sum == target) {
            res.add(new ArrayList(path));
            return;
        }
        
        for(int i = start; i < candidates.length && sum + candidates[i] <= target; i++) {
            if(i > start && candidates[i] == candidates[i - 1])    continue;
            path.add(candidates[i]);
            sum += candidates[i];
            backtracking(i + 1, candidates, sum, target);
            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```


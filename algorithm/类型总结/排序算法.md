### 总体比较

| **排序算法** | **平均时间复杂度** | **最坏时间复杂度** | **最好时间复杂度** | **空间复杂度** | **稳定性** |
| ------------ | ------------------ | ------------------ | ------------------ | -------------- | ---------- |
| **冒泡排序** | O(n²)              | O(n²)              | O(n)               | O(1)           | 稳定       |
| **快速排序** | O(nlogn)           | O(n²)              | O(nlogn)           | O(nlogn)       | 不稳定     |
| **堆排序**   | O(nlogn)           | O(nlogn)           | O(nlogn)           | O(1)           | 不稳定     |
| **归并排序** | O(nlogn)           | O(nlogn)           | O(nlogn)           | O(n)           | 稳定       |

### 排序代码

#### 冒泡排序

```java
public int[] bubbleSort(int[] nums) {
    int n = nums.length;
    for(int i = n - 1; i >= 0; i--) {
        for(int j = 0; j < i; j++) {
            if(nums[j] > nums[j + 1]) {
                int tmp = nums[j + 1];
                nums[j + 1] = nums[j];
                nums[j] = tmp;
            }
        }
    }
    return nums;
}
```

#### 快速排序

```java
public void quickSort(int[] nums, int left, int right) {
    // 结束条件
    if(left >= right)   return;
    int l = left, r = right;
    int pivot = nums[left];
    // 找到 pivot 的位置
    while(l < r) {
        while(l < r && nums[r] >= pivot)    r--;
        nums[l] = nums[r]; // 将比 pivot 小的值移到左边
        while(l < r && nums[l] <= pivot)    l++;
        nums[r] = nums[l]; // 将比 pivot 大的值移到右边
    }
    // 给该位置赋值
    nums[l] = pivot;

    quickSort(nums, left, l - 1);
    quickSort(nums, l + 1, right);
}
```

#### 归并排序

```java
public void mergeSort(int[] nums, int left, int right) {
    int mid = left + (right - left) / 2;
    if(left < right) {
        // 类似于后序遍历，从小范围到大范围
        mergeSort(nums, left, mid); // 左
        mergeSort(nums, mid + 1, right); // 右
        merge(nums, left, mid, right); // 跟的操作
    }
}

public void merge(int[] nums, int left, int mid, int right) {
    int[] tmp = new int[right - left + 1];
    int i = left, j = mid + 1;
    int idx = 0;
    // 两个有序数组的合并
    while(i <= mid && j <= right) {
        if(nums[i] < nums[j]) tmp[idx++] = nums[i++];
        else  tmp[idx++] = nums[j++];
    }
    while(i <= mid) tmp[idx++] = nums[i++];
    while(j <= right)   tmp[idx++] = nums[j++];
	// java 值传递需要赋值操作
    for(int k = 0; k < tmp.length; k++)     nums[left + k] = tmp[k];
}
```

#### 堆排序

暂定

```java
public void heapSort(int[] nums)
{
    int n = nums.length;
    int parent = n / 2 - 1;
    // 从父节点到根节点
    for (int i = parent; i >= 0; i--)   HeapAdjust(nums, i, n - 1);

    for(int i = n - 1; i >= 0; i--)
    {
        swap(nums, 0, i);
        HeapAdjust(nums, 0, i-1);//从上到下，从左向右调整
    }
}
public void HeapAdjust(int[] nums, int parent, int end)
{
    int child = parent * 2 + 1;
    int val = nums[parent];

    while(child <= end) {
        // 比较左右子节点的大小
        if(child < end && nums[child] < nums[child + 1])   child++;
        // 父节点为父子节点中较大值
        if(nums[parent] >= nums[child])    break;
        else {
            nums[parent] = nums[child];
            nums[child] = val;
        }
        // 切换到子树的调整
        parent = child;
        child = parent * 2 + 1;
        val = nums[parent];
    }
}

public void swap(int[] nums, int i, int j) {
    int tmp = nums[j];
    nums[j] = nums[i];
    nums[i] = tmp;
}
```



[排序算法时间复杂度、空间复杂度、稳定性比较](https://blog.csdn.net/pange1991/article/details/85460755)
### 什么是系统调用？

> 需要进入内核态由操作系统完成的资源调用操作

程序访问内核态级别的资源时，需要通过系统调用的方式，由操作系统完成的操作。

- 进程管理（进程控制和进程通信）
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。

## 进程和线程

### 进程与线程的区别总结？

- 根本区别

进程是操作系统资源分配的基本单位，而线程是 CPU 调度和执行的基本单位

- 资源分配 & 包含关系

进程有独立的地址空间，维护代码段、数据段和堆栈段，进程之间的切换会有较大的开销

每个线程都有自己独立的程序计数器（PC）和运行栈，同一进程的线程共享代码和数据空间，使用相同的地址空间，因此线程之间切换的开销小

**创建线程的开销要比进程小很多**，因为创建线程仅仅需要`堆栈指针`和`程序计数器`就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，开销较大。

线程是进程的一部分，但是由于线程没有单独的地址空间，所以不能独立执行，必须依赖于进程的执行

- 影响关系

在用户态模式下，一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃会让整个进程崩溃。所以多进程要比多线程健壮。

- 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

#### JVM 角度线程和进程之间的关系

一个进程中可以有多个线程，多个线程共享进程的 `堆` 和 `方法区` (JDK1.8 之后的元空间)资源，但是每个线程有自己的 `程序计数器`、`虚拟机栈` 和 `本地方法栈`。

![Java 内存区域](https://camo.githubusercontent.com/1f2bc9c14b6a22209e6e511486388c759da958f9b793d952a632f11aa1daed03/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66663936666564306532613335346262313662626338346463656466353033612e706e67)

### 进程有哪几种状态?

- 创建状态(new) ：进程正在被创建，尚未到就绪状态。
- 就绪状态(ready) ：进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- 运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行。如 `等待某资源为可用` 或 `等待 IO 操作完成`。
- 结束状态(terminated) ：进程正常结束或其他原因中断退出运行。

![进程运行状态](https://camo.githubusercontent.com/fa3044833393a5a207f155bc6e72f8f750f2d370ca7488ce114e6e5c7f666bf8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f64333832303235393330313262343537646562626364373439393463363239322e706e67)

### 进程间的通信方式（Inter Process Communication，IPC）有哪些？

- 管道(Pipes)

通过调用 pipe 函数创建，用于父子进程或兄弟进程通信

 `int pipe(int fd[2]);` fd[0] 用于读，fd[1] 用于写

- 命名管道（Names Pipes）

去除了管道只能在父子进程中使用的限制，可以实现本机任意两个进程通信

- 信号(Signal)

信号用于通知接收进程某个事件已经发生

- 消息队列(Message Queuing) 

消息队列是消息的链表，克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺点

- 信号量(Semaphores) 

信号量是一个计数器，用于多进程对共享数据的访问，主要是为了进程间同步。

- 共享内存(Shared memory) 

多个进程可以访问同一块内存空间，是最快的一种 IPC。需要依赖信号量等进行进程间的同步。

- 套接字(Sockets)

可用于不同机器之间的进程通信，通过套接字中的相关函数来完成通信过程。

![Socket 连接](https://img-blog.csdn.net/20151218101102971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

  ### 线程间的同步的方式有哪些

- 互斥量(Mutex)

只有一个对象，同一时刻只能由一个线程访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

- 信号量(Semphares) 

允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

- 事件(Event)

Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## 内存管理

### 内存管理的作用

- 内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存）

- 逻辑地址到物理地址的转换

### 内存管理有哪几种方式？

**连续分配**

- 块式管理：一个进程占用一个内存块，利用率低

**非连续分配**

- 页式管理：把主存分为大小相等且固定的一页一页的形式，提高内存利用率。通过页表转换逻辑地址和物理地址
- 段式管理：把每个表分成段，一个段构成一个独立的地址空间。具有逻辑意义，例如代码段、数据段、堆栈
- 段页式管理：每个段上的地址空间划分成大小相同的页。既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能

### 页表管理中的快表和多级页表？

**快表**：解决虚拟地址到物理地址的转换速度。应用程序的局部性原理，相当于页表的缓存（cache）

**多级页表**：相当于做了多级索引，节省内存空间。因为一般进程使用的内存是远低于全部虚拟内存。时间换空间。

为了提高内存的空间性能，提出了多级页表的概念；为了补充损失的时间性能，提出了快表（ TLB）的概念。都利用到了程序的局部性原理。

### 分页机制和分段机制的共同点和区别？

**共同点**

- 都是为了提高内存利用率
- 都是非连续存储

**区别**

- 页的大小固定，由操作系统决定；段的大小不固定，取决于运行的程序。
- 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间，有助于共享和保护。

### 介绍一下虚拟内存

**虚拟内存**

虚拟内存是内存管理的一种技术，是程序和物理内存之间的「中间件」。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片。还有部分暂时存储在外部磁盘存储器上（Swap），在需要时进行数据交换。

**虚拟内存的作用**

- 看做磁盘的缓存，提高内存利用率
- 每个进程都有统一的线性地址空间，可以作为内存管理工具，简化内存管理
- 保护了每个进程的地址空间不会被其他进程破坏

**物理地址 ——> 逻辑地址**

通过内存管理单元（MMU）。一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

### 页面置换算法的作用？

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存没有空闲页面，系统必须在内存选择一个页面将其移出内存，以便让缺失的页面换到内存中。

### 常见的页面置换算法有哪些?

- 最佳置换（OPT）算法：所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面
- 先进先出页（FIFO）算法：总是淘汰最先进入内存的页面
- 最近最久未使用（LRU）算法：淘汰距离现在使用时间最久的页面
- 最少使用（LFU）算法：之前时期使用最少的页面作为淘汰页

## 死锁

### 死锁产生的必要条件

- 互斥：排他性控制
- 不剥夺：在未使用完毕之前，不能被其他进程强行夺走
- 请求和保持：已经得到了某个资源的进程再请求新的资源
- 循环等待：已有资源的进程请求新的资源形成一条环路

[CS-Notes 计算机操作系统 - 死锁](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md)

